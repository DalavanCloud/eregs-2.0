{
    "docs": [
        {
            "location": "/", 
            "text": "eRegs 2.0\n\n\nThis is the documentation for the new version of \neRegs\n, the interface for reading the Bureau's regulatory documents. This document describes how to deploy eRegs, add and update content, and troubleshoot.\n\n\nGetting eRegs\n\n\neRegs can be checked out from the Github repository:\n\n\ngit clone https://github.com/cfpb/eregs-2.0\ncd eregs-2.0\npip install -r requirements.txt\n\n\n\nThe other thing you'll need is the \neregsip\n repository, which contains some static content for branding. If you are inside the CFPB developer VPN, you know where you can find this repository, and if you're not, you'll have to go without. You can run the project without this repository, but some static assets will be missing.\n\n\nInstalling the prerequisites\n\n\nIn addition to installing the various required Python modules, you will need to install and configure a MySQL database and an ElasticSearch instance. If you are developing on a Mac, you should be able to install both of these via \nhomebrew\n like so:\n\n\nbrew install mysql\nbrew install elasticsearch23\n\n\n\nNote that you will need ElasticSearch 2.3, not one of the later versions, which do not work correctly with Haystack, the search interface between Django and a search backend. \n\n\nOnce you have MySQL installed, you'll need to configure it to match the \nsettings.py\n file. You should create two users, \neregs\n and \ntest_eregs\n, both authenticated by the password \neregs\n. Once that's done, you should run \n./manage.py migrate\n to create the database and the model tables. You should also make sure that ElasticSearch is running.\n\n\nLoading data\n\n\nIn order to load data, you'll need to grab the repository that contains the RegML files. Wherever you want to have this data, do:\n\n\ngit clone https://github.com/cfpb/regulations-xml\n\n\n\nThis repository has the following structure:\n\n\nimages                     # images that are embedded in the regulations\nnotice/                    # change notices for each regulation\n    1003/                  # reg C\n        2012-31311.xml\n        ...                # etc.\n    1005/                  # reg E\n        2012-01728.xml\n        ...                # etc.\n    ...                    # etc.\nregulation/                # compiled regulations\n    1003/                  # reg C\n        2011-31712.xml     # initial version of the regulation\n        2012-31311.xml     # result of applying first notice\n        ...                # etc.\n    ...                    # etc.\n\n\n\nIf you run \n./manage.py runserver\n and go to \nlocalhost:8000\n, you'll see that there is no content in eRegs. To load some content, run the following management command:\n\n\n./manage.py import_xml /path/to/regulations-xml/regulation/1003/2011-31712.xml\n\n\n\nThis will import the initial version of Regulation C into eRegs. If you refresh your view, you will now see Regulation C on the landing page. You should be able to navigate the regulation interface in the same way that you navigate the current production eRegs interface.\n\n\nIn order to get search to work, you'll need to build the index:\n\n\n./manage.py rebuild_index\n\n\n\nThis will build the ElasticSearch index for eRegs. In the future, you can update the index by running \n./manage.py update_index\n. You should now be able to search the eRegs regulatory text in the normal manner.\n\n\nLoading diffs\n\n\nDiffs are a special form of content that indicate the difference between two versions of a regulation. It is important to note that diffs are \nnot\n symmetric; in other words, if \nX\n and \nY\n are versions of a single regulation, \ndiff(X, Y) != diff(Y, X)\n. Therefore, right now, if you want to display bidirectional differences in regulatory content, you need to generate diffs in both directions. There's a command to do that:\n\n\n./manage.py import_diff /path/to/regulations-xml/regulation/regnumber/version1.xml /path/to/regulations-xml/regulation/regnumber/version2.xml\n./manage.py import_diff /path/to/regulations-xml/regulation/regnumber/version2.xml /path/to/regulations-xml/regulation/regnumber/version1.xml\n\n\n\nHere, \nregnumber\n is the part number of the regulation (e.g. 1003) and \nversion1\n and \nversion2\n are the document numbers of the respective versions. Make sure that \nregnumber\n is the same in both cases; you can of course generate a diff between two different part numbers, but that diff would make no sense. In the future, there will be a single management command that will generate the bidirectional diffs for you, but for the moment, you have to run it twice with the arguments swapped, as above, to have differences in both directions.", 
            "title": "Installation and Data Loading"
        }, 
        {
            "location": "/#eregs-20", 
            "text": "This is the documentation for the new version of  eRegs , the interface for reading the Bureau's regulatory documents. This document describes how to deploy eRegs, add and update content, and troubleshoot.", 
            "title": "eRegs 2.0"
        }, 
        {
            "location": "/#getting-eregs", 
            "text": "eRegs can be checked out from the Github repository:  git clone https://github.com/cfpb/eregs-2.0\ncd eregs-2.0\npip install -r requirements.txt  The other thing you'll need is the  eregsip  repository, which contains some static content for branding. If you are inside the CFPB developer VPN, you know where you can find this repository, and if you're not, you'll have to go without. You can run the project without this repository, but some static assets will be missing.", 
            "title": "Getting eRegs"
        }, 
        {
            "location": "/#installing-the-prerequisites", 
            "text": "In addition to installing the various required Python modules, you will need to install and configure a MySQL database and an ElasticSearch instance. If you are developing on a Mac, you should be able to install both of these via  homebrew  like so:  brew install mysql\nbrew install elasticsearch23  Note that you will need ElasticSearch 2.3, not one of the later versions, which do not work correctly with Haystack, the search interface between Django and a search backend.   Once you have MySQL installed, you'll need to configure it to match the  settings.py  file. You should create two users,  eregs  and  test_eregs , both authenticated by the password  eregs . Once that's done, you should run  ./manage.py migrate  to create the database and the model tables. You should also make sure that ElasticSearch is running.", 
            "title": "Installing the prerequisites"
        }, 
        {
            "location": "/#loading-data", 
            "text": "In order to load data, you'll need to grab the repository that contains the RegML files. Wherever you want to have this data, do:  git clone https://github.com/cfpb/regulations-xml  This repository has the following structure:  images                     # images that are embedded in the regulations\nnotice/                    # change notices for each regulation\n    1003/                  # reg C\n        2012-31311.xml\n        ...                # etc.\n    1005/                  # reg E\n        2012-01728.xml\n        ...                # etc.\n    ...                    # etc.\nregulation/                # compiled regulations\n    1003/                  # reg C\n        2011-31712.xml     # initial version of the regulation\n        2012-31311.xml     # result of applying first notice\n        ...                # etc.\n    ...                    # etc.  If you run  ./manage.py runserver  and go to  localhost:8000 , you'll see that there is no content in eRegs. To load some content, run the following management command:  ./manage.py import_xml /path/to/regulations-xml/regulation/1003/2011-31712.xml  This will import the initial version of Regulation C into eRegs. If you refresh your view, you will now see Regulation C on the landing page. You should be able to navigate the regulation interface in the same way that you navigate the current production eRegs interface.  In order to get search to work, you'll need to build the index:  ./manage.py rebuild_index  This will build the ElasticSearch index for eRegs. In the future, you can update the index by running  ./manage.py update_index . You should now be able to search the eRegs regulatory text in the normal manner.", 
            "title": "Loading data"
        }, 
        {
            "location": "/#loading-diffs", 
            "text": "Diffs are a special form of content that indicate the difference between two versions of a regulation. It is important to note that diffs are  not  symmetric; in other words, if  X  and  Y  are versions of a single regulation,  diff(X, Y) != diff(Y, X) . Therefore, right now, if you want to display bidirectional differences in regulatory content, you need to generate diffs in both directions. There's a command to do that:  ./manage.py import_diff /path/to/regulations-xml/regulation/regnumber/version1.xml /path/to/regulations-xml/regulation/regnumber/version2.xml\n./manage.py import_diff /path/to/regulations-xml/regulation/regnumber/version2.xml /path/to/regulations-xml/regulation/regnumber/version1.xml  Here,  regnumber  is the part number of the regulation (e.g. 1003) and  version1  and  version2  are the document numbers of the respective versions. Make sure that  regnumber  is the same in both cases; you can of course generate a diff between two different part numbers, but that diff would make no sense. In the future, there will be a single management command that will generate the bidirectional diffs for you, but for the moment, you have to run it twice with the arguments swapped, as above, to have differences in both directions.", 
            "title": "Loading diffs"
        }, 
        {
            "location": "/regml/", 
            "text": "Logic, motivation, and use\n\n\nThis part of the documentation explains the motivation for switching to an XML format and the way in which this change simplifies the process of adding content into eRegs.\n\n\nregulations-parser\n\n\nThe process of creating the content that powers eRegs begins with a Python program called \nregulations-parser\n. The parser takes as its input the raw XML from the Federal Register. In the past, the parser would generate the JSON layers described in the \nAPI\n section, and they would be stored in the database as indicated on the diagram. Now, the parser generates a set of XML files; the first of these files represents the document that originates the regulation (e.g. \n2011-31712.xml\n for the original document of Regulation C), and the subsequent XML documents represent notices that modify the \nprevious\n version of the regulation. Thus, if \n2011-31712\n is the original version, and \n2012-31311\n is the notice representing the chronologically next modification, then \"applying\" the \nnotice\n \n2011-31311\n to the \nregulation\n \n2011-31712\n generates the \nnew reguation\n \n2011-31311\n. The \nnext\n notice will then modify the regulation \n2011-31311\n, and so on.\n\n\nThe benefit of this structure is that fixes that are made upstream propagate downstread. In the old pipeline, modifying the individual JSON files was too complicated, so any changes had to be made to the source Federal Register XML and the entire parser needed to be run again. This made the process of compiling regulations hopelessly opaque and slow, especially for larger regulations like Z. With the introduction of RegML, initial mistakes in compilation can be fixed in the root version, and then incremental fixes can be made in the notices, which are typically much smaller than a fully compiled regulation. Once you have fixed version \nN\n and notice \nN+1\n, version \nN+1\n which is obtained by applying notice \nN+1\n to version \nN\n, will maintain those fixes. This makes it possible to incrementally fix mistakes in regulation compilation.\n\n\nAdditionally, fixing an XML file that can be validated with a schema is much easier than fixing the typically malformed, non-semantic XML that the Federal Register provides. RegML was designed with the goal of capturing the entire semantics of a regulation, whereas the Federal Register XML is designed to be compiled to a printable PDF. In particular, RegML is designed to have a 1-1 correspondence between XML node and Django database model, as well as with the goal of separating visual representation from semantic markup. Thus, fixing errors in a RegML file requires substantially less time and effort.\n\n\nThe logic of RegML\n\n\nRegML is designed to capture regulation semantics, separate model structure from presentation, and maintain an isomorphism between XML node and database row. You can find \nthe schema for RegML\n on Github. The schema is amply documented and should be mostly self-explanatory; it captures both the structure of a regulatory document in the form of a hierarchy of nodes, and the semantics of the text that indicate linkages between different parts of the regulation, such as definitions and references.\n\n\nPowering eRegs 2.0\n\n\nAs documented in the \nAPI\n section and the \nintroduction\n, the new eRegs backend replaces the Byzantine collection of JSON layers with a storage logic based on nested sets. Now, instead of breaking the RegML file into layers and then reassembling them on the site backend, the entire RegML tree can just be imported directly into the database. This eliminates the necessity of uploading large files (an update to Regulation Z can be as much as ~10Gb), and makes it much easier to store the canonical representation of a regulation in a repository. This also aids automation, as it is possible to automatically pull down an updated production branch of a repository and insert it into the database without the need of passing through multiple pipeline stages.", 
            "title": "RegML"
        }, 
        {
            "location": "/regml/#logic-motivation-and-use", 
            "text": "This part of the documentation explains the motivation for switching to an XML format and the way in which this change simplifies the process of adding content into eRegs.", 
            "title": "Logic, motivation, and use"
        }, 
        {
            "location": "/regml/#regulations-parser", 
            "text": "The process of creating the content that powers eRegs begins with a Python program called  regulations-parser . The parser takes as its input the raw XML from the Federal Register. In the past, the parser would generate the JSON layers described in the  API  section, and they would be stored in the database as indicated on the diagram. Now, the parser generates a set of XML files; the first of these files represents the document that originates the regulation (e.g.  2011-31712.xml  for the original document of Regulation C), and the subsequent XML documents represent notices that modify the  previous  version of the regulation. Thus, if  2011-31712  is the original version, and  2012-31311  is the notice representing the chronologically next modification, then \"applying\" the  notice   2011-31311  to the  regulation   2011-31712  generates the  new reguation   2011-31311 . The  next  notice will then modify the regulation  2011-31311 , and so on.  The benefit of this structure is that fixes that are made upstream propagate downstread. In the old pipeline, modifying the individual JSON files was too complicated, so any changes had to be made to the source Federal Register XML and the entire parser needed to be run again. This made the process of compiling regulations hopelessly opaque and slow, especially for larger regulations like Z. With the introduction of RegML, initial mistakes in compilation can be fixed in the root version, and then incremental fixes can be made in the notices, which are typically much smaller than a fully compiled regulation. Once you have fixed version  N  and notice  N+1 , version  N+1  which is obtained by applying notice  N+1  to version  N , will maintain those fixes. This makes it possible to incrementally fix mistakes in regulation compilation.  Additionally, fixing an XML file that can be validated with a schema is much easier than fixing the typically malformed, non-semantic XML that the Federal Register provides. RegML was designed with the goal of capturing the entire semantics of a regulation, whereas the Federal Register XML is designed to be compiled to a printable PDF. In particular, RegML is designed to have a 1-1 correspondence between XML node and Django database model, as well as with the goal of separating visual representation from semantic markup. Thus, fixing errors in a RegML file requires substantially less time and effort.", 
            "title": "regulations-parser"
        }, 
        {
            "location": "/regml/#the-logic-of-regml", 
            "text": "RegML is designed to capture regulation semantics, separate model structure from presentation, and maintain an isomorphism between XML node and database row. You can find  the schema for RegML  on Github. The schema is amply documented and should be mostly self-explanatory; it captures both the structure of a regulatory document in the form of a hierarchy of nodes, and the semantics of the text that indicate linkages between different parts of the regulation, such as definitions and references.", 
            "title": "The logic of RegML"
        }, 
        {
            "location": "/regml/#powering-eregs-20", 
            "text": "As documented in the  API  section and the  introduction , the new eRegs backend replaces the Byzantine collection of JSON layers with a storage logic based on nested sets. Now, instead of breaking the RegML file into layers and then reassembling them on the site backend, the entire RegML tree can just be imported directly into the database. This eliminates the necessity of uploading large files (an update to Regulation Z can be as much as ~10Gb), and makes it much easier to store the canonical representation of a regulation in a repository. This also aids automation, as it is possible to automatically pull down an updated production branch of a repository and insert it into the database without the need of passing through multiple pipeline stages.", 
            "title": "Powering eRegs 2.0"
        }, 
        {
            "location": "/api/", 
            "text": "eRegs API - a guided tour\n\n\nThis part of the documentation provides an explanation of the eRegs API and the design, storage, and view logic of the project.\n\n\nDifferences from old eRegs\n\n\nThe eRegs API is drastically revised from the previous version. Before the advent of eRegs 2.0, the eRegs deployment process involved breaking a regulation up into its constituent parts, storing those parts in the database as \"layers\", and then reassembling those layers into the final display version of the regulation. The diagram below illustrates the old eRegs content generation process:\n\n\n\n\nNot only was this process complicated and error-prone (in particular, the assembly of layers into the display HTML could fail in unexpected ways if some crucial piece of content was missing from the JSON layers), but it also took an extremely long time, especially for giant regulations like Z. Furthermore, because of the original design of eRegs, the storage logic actually lived in a different project called \nregcore\n which provided an API to \nregsite\n, which was the actual project that fetched the data and displayed it.\n\n\nIn the new version of eRegs, all of this complexity has been eliminated. The new eRegs stores the regulation tree directly in a single table and designates a node's position in the regulation tree hierarchy through the use of \nnested sets\n. The \nregcore\n project is eliminated entirely and display HTML is generated directly via server-side templating. The result is the following conceptual diagram, encompassed by a single project:\n\n\n\n\nURL scheme\n\n\nThe old eRegs API contained a complicated URL scheme which required a great deal of complicated server-side processing in order to render the appropriate content. The new API simplifies the URL scheme using the principle that there are three pieces of data that uniquely identify a node within the regulatory structure: the document number, the effective date, and the node label. Althought not every node in the tree has a label, every node \neither\n has a label \nor\n is uniquely associated with a labeled node (in principle, every node \ncould\n have a label, if it is so desired), and any node \nthat can be navigated to\n has a label.\n\n\nThe document number identifies the actual document, as issued by the Federal Register, in which the content originates. For example, the initial document that originates Regulation C has the document number \n2011-31712\n. A document contains at least one, but possibly more effective dates, which indicate on which date the regulatory text becomes effective. An example of this is a document that amends Regulation C, \n2015-26607\n, which contains \nthree\n effective dates (1/1/2017, 1/1/2018, and 1/1/2019). Obviously, multiple regulations may become effective on the same date.\n\n\nThe label of a node uniquely identifies the node \nwithin that specific regulation tree\n. With a few exceptions, the label consists of the part number, either the section number or the appendix letter, and the paragraph marker(s), separated by dashes. For example, Section 1 in Regulation C will have the label \n1003-1\n, the first paragraph in that section has label \n1003-1-a\n and so on. Nodes for interpretations have the form of the node to which they are appended, followed by the word \nInterp\n, and then followed by paragraph markers indicating the internal structure of the interpretation paragraph or section. So, for example, the interpretation of paragraph (a)(1) of section 3 will have the label \n1003-3-a-1-Interp\n, and its first paragraph would have the label \n1003-3-a-1-Interp-1\n, and so on.\n\n\nTogether, the document number, the effective date, and the label, separated by colons, are combined into a uniquely identifying \nnode_id\n. Thus, paragraph (a) of section 1 of Regulation C from the document \n2011-31712\n effective on \n2011-12-30\n will have the \nnode_id\n of \n2011-31712:2011-12-30:1003-1-a\n. Accoringly, that node (or any other node with a label) can be accessed via the url \nlocalhost:8000/regulation/2011-31712/2011-12-30/1003-1-a\n.\n\n\nModel logic\n\n\nThe entire storage logic of the new eRegs is rooted in a single model, \nRegNode\n. That model defines the basic properties of a node (\nlabel\n, \ntext\n, \ntag\n, \nnode_id\n). It also defines a \nversion\n property, which is the document number and effective date concatenated together with a colon, e.g. \n2011-31712:2011-12-30\n. There is also an \nattribs\n property which is a \nJSONField\n (present only in MySQL 5.7+ and PostgreSQL 9.3+). The \nattribs\n field contains all the data that would be present as an attribute in the RegML, e.g. \nparagraph marker=(a)\n would generate a \nRegNode\n whose \nattribs\n dictionary would contain a \nmarker\n key whose value is \n(a)\n. The \nRegNode\n inherits some generic node functions for fetching descendants and ancestors of an element in a nested set (\nGenericNodeMixin\n) and provides some additional functionality for testing the type of internal list that the node contains, if any, and which of its children have content, if any.\n\n\nSubsequent node types are derived from \nRegNode\n as proxy models, which means that they do not have their own table; they are simply extensions of the \nRegNode\n that provide additional functionality. So, for example, the \nParagraph\n model contains additional functionality for displaying the paragraphs, and so on. There is a one-to-one correspondence between the \ntag\n of a node (as obtained from the RegML), which allows automatic inference of node class when retrieving descendants and ancestors.\n\n\nThe only special node that is derived from \nRegNode\n is the \nDiffNode\n, which \ndoes\n have its own table. The difference between \nRegNode\n and \nDiffNode\n is that the \nDiffNode\n contains \ntwo\n version fields, \nleft_version\n and \nright_version\n, which carry the same semantics as the \nversion\n field of \nRegNode\n. Thus, every \nDiffNode\n in the table encodes the difference between the left and right versions of the regulation. As noted in the \ninstallation\n guide, diffs are \nnot\n symmetric; thus a \nDiffNode\n with \nleft version = X\n and \nright_version = Y\n is not necessarily identical to one with \nleft_version = Y\n and \nright_version = X\n. Additionally, all node models which can encode version-differing content have accessory functions for retrieving the left and right versions of the content, as well as for rendering it.\n\n\nView logic\n\n\nThe view logic in eRegs 2.0 is also drastically simplified relative to the old version of eRegs. The basic structure of a view is that it's identified by its functionality prepended to the aforementioned URL scheme, so that e.g. a node within a regulation has the relative URL \nregulation/2011-31712/2011-12-30/1003-1-a\n. Most of the other views are intended to render partials, and thus the URL is prepended with e.g. \npartial/sxs/\n or \npartial/definition/\n. Views that render partials return the appropriate HTML directly to the caller, which can then be appended in the correct place on the front-end.\n\n\nTemplate logic\n\n\nThe major templating work happens in the \nregnode.html\n file. The basic logic of that file is to render the regulation tree, starting at the specified root node, in a recursive fashion. Thus, depending on the type of node, \nregnode.html\n renders the opening HTML tag, recurses into the node to render its insides, and then renders the closing HTML tag on the way back up. There are some templates that render content independent of this structure (for example the sidebar, analysis, and table of contents are rendered separately). This simplifies the process of the old eRegs, in which the various JSON layers were assembled into the final rendered HTML; instead, there is a single point of entry for most rendering and substantially fewer places where an exception could happen.", 
            "title": "API"
        }, 
        {
            "location": "/api/#eregs-api-a-guided-tour", 
            "text": "This part of the documentation provides an explanation of the eRegs API and the design, storage, and view logic of the project.", 
            "title": "eRegs API - a guided tour"
        }, 
        {
            "location": "/api/#differences-from-old-eregs", 
            "text": "The eRegs API is drastically revised from the previous version. Before the advent of eRegs 2.0, the eRegs deployment process involved breaking a regulation up into its constituent parts, storing those parts in the database as \"layers\", and then reassembling those layers into the final display version of the regulation. The diagram below illustrates the old eRegs content generation process:   Not only was this process complicated and error-prone (in particular, the assembly of layers into the display HTML could fail in unexpected ways if some crucial piece of content was missing from the JSON layers), but it also took an extremely long time, especially for giant regulations like Z. Furthermore, because of the original design of eRegs, the storage logic actually lived in a different project called  regcore  which provided an API to  regsite , which was the actual project that fetched the data and displayed it.  In the new version of eRegs, all of this complexity has been eliminated. The new eRegs stores the regulation tree directly in a single table and designates a node's position in the regulation tree hierarchy through the use of  nested sets . The  regcore  project is eliminated entirely and display HTML is generated directly via server-side templating. The result is the following conceptual diagram, encompassed by a single project:", 
            "title": "Differences from old eRegs"
        }, 
        {
            "location": "/api/#url-scheme", 
            "text": "The old eRegs API contained a complicated URL scheme which required a great deal of complicated server-side processing in order to render the appropriate content. The new API simplifies the URL scheme using the principle that there are three pieces of data that uniquely identify a node within the regulatory structure: the document number, the effective date, and the node label. Althought not every node in the tree has a label, every node  either  has a label  or  is uniquely associated with a labeled node (in principle, every node  could  have a label, if it is so desired), and any node  that can be navigated to  has a label.  The document number identifies the actual document, as issued by the Federal Register, in which the content originates. For example, the initial document that originates Regulation C has the document number  2011-31712 . A document contains at least one, but possibly more effective dates, which indicate on which date the regulatory text becomes effective. An example of this is a document that amends Regulation C,  2015-26607 , which contains  three  effective dates (1/1/2017, 1/1/2018, and 1/1/2019). Obviously, multiple regulations may become effective on the same date.  The label of a node uniquely identifies the node  within that specific regulation tree . With a few exceptions, the label consists of the part number, either the section number or the appendix letter, and the paragraph marker(s), separated by dashes. For example, Section 1 in Regulation C will have the label  1003-1 , the first paragraph in that section has label  1003-1-a  and so on. Nodes for interpretations have the form of the node to which they are appended, followed by the word  Interp , and then followed by paragraph markers indicating the internal structure of the interpretation paragraph or section. So, for example, the interpretation of paragraph (a)(1) of section 3 will have the label  1003-3-a-1-Interp , and its first paragraph would have the label  1003-3-a-1-Interp-1 , and so on.  Together, the document number, the effective date, and the label, separated by colons, are combined into a uniquely identifying  node_id . Thus, paragraph (a) of section 1 of Regulation C from the document  2011-31712  effective on  2011-12-30  will have the  node_id  of  2011-31712:2011-12-30:1003-1-a . Accoringly, that node (or any other node with a label) can be accessed via the url  localhost:8000/regulation/2011-31712/2011-12-30/1003-1-a .", 
            "title": "URL scheme"
        }, 
        {
            "location": "/api/#model-logic", 
            "text": "The entire storage logic of the new eRegs is rooted in a single model,  RegNode . That model defines the basic properties of a node ( label ,  text ,  tag ,  node_id ). It also defines a  version  property, which is the document number and effective date concatenated together with a colon, e.g.  2011-31712:2011-12-30 . There is also an  attribs  property which is a  JSONField  (present only in MySQL 5.7+ and PostgreSQL 9.3+). The  attribs  field contains all the data that would be present as an attribute in the RegML, e.g.  paragraph marker=(a)  would generate a  RegNode  whose  attribs  dictionary would contain a  marker  key whose value is  (a) . The  RegNode  inherits some generic node functions for fetching descendants and ancestors of an element in a nested set ( GenericNodeMixin ) and provides some additional functionality for testing the type of internal list that the node contains, if any, and which of its children have content, if any.  Subsequent node types are derived from  RegNode  as proxy models, which means that they do not have their own table; they are simply extensions of the  RegNode  that provide additional functionality. So, for example, the  Paragraph  model contains additional functionality for displaying the paragraphs, and so on. There is a one-to-one correspondence between the  tag  of a node (as obtained from the RegML), which allows automatic inference of node class when retrieving descendants and ancestors.  The only special node that is derived from  RegNode  is the  DiffNode , which  does  have its own table. The difference between  RegNode  and  DiffNode  is that the  DiffNode  contains  two  version fields,  left_version  and  right_version , which carry the same semantics as the  version  field of  RegNode . Thus, every  DiffNode  in the table encodes the difference between the left and right versions of the regulation. As noted in the  installation  guide, diffs are  not  symmetric; thus a  DiffNode  with  left version = X  and  right_version = Y  is not necessarily identical to one with  left_version = Y  and  right_version = X . Additionally, all node models which can encode version-differing content have accessory functions for retrieving the left and right versions of the content, as well as for rendering it.", 
            "title": "Model logic"
        }, 
        {
            "location": "/api/#view-logic", 
            "text": "The view logic in eRegs 2.0 is also drastically simplified relative to the old version of eRegs. The basic structure of a view is that it's identified by its functionality prepended to the aforementioned URL scheme, so that e.g. a node within a regulation has the relative URL  regulation/2011-31712/2011-12-30/1003-1-a . Most of the other views are intended to render partials, and thus the URL is prepended with e.g.  partial/sxs/  or  partial/definition/ . Views that render partials return the appropriate HTML directly to the caller, which can then be appended in the correct place on the front-end.", 
            "title": "View logic"
        }, 
        {
            "location": "/api/#template-logic", 
            "text": "The major templating work happens in the  regnode.html  file. The basic logic of that file is to render the regulation tree, starting at the specified root node, in a recursive fashion. Thus, depending on the type of node,  regnode.html  renders the opening HTML tag, recurses into the node to render its insides, and then renders the closing HTML tag on the way back up. There are some templates that render content independent of this structure (for example the sidebar, analysis, and table of contents are rendered separately). This simplifies the process of the old eRegs, in which the various JSON layers were assembled into the final rendered HTML; instead, there is a single point of entry for most rendering and substantially fewer places where an exception could happen.", 
            "title": "Template logic"
        }
    ]
}